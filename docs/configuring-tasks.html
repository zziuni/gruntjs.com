<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Configuring tasks - Grunt: The JavaScript Task Runner</title><link rel="stylesheet" href="css/main.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:400,700"><link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"><link href="/rss" rel="alternate" title="Grunt Blog Feed" type="application/atom+xml"><script src="js/vendor/lib/modernizr.min.js"></script></head><body class="page-docs page-secondary"><div class="navbar navbar-inverse"><div class="navbar-inner"><div class="container"><a href="/" class="brand"><span class="logo"></span></a><div class="nav-collapse collapse"><ul class="nav"><li><a href="/getting-started"><i class="icon-arrow-right"></i><span>Getting Started</span></a></li><li><a href="/plugins"><i class="icon-power-cord"></i><span>Plugins</span></a></li><li><a href="/getting-started"><i class="icon-document-alt-stroke"></i><span>Documentation</span></a></li><li><a href="/api"><i class="icon-cog"></i><span>API</span></a></li></ul><form class="navbar-search pull-right"><input type="text" placeholder="Search" class="search-query"></form></div><!--.nav-collapse--></div></div></div><div class="content"><div class="container configuring-tasks"><div class="row-fluid"><div class="span9 page"><div class="hero-unit"><h1>Configuring tasks</h1><p>이 문서는 <code>Gruntfile</code>를 사용하는 프로젝트를 위해서 task 단위로 환경설정을 하는 법을 설명한다. <code>Gruntfile</code>에 대해 잘 모른다면 <a href="/getting-started/">Getting Started</a>문서를 먼저 읽어보고 <a href="/sample-gruntfile/">Sample Gruntfile</a> 파일을 체크아웃 받자.</p>
<h2><a class="anchor" href="#grunt-configuration" name="grunt-configuration">Grunt Configuration</a></h2>
<p>task 환경설정은 <code>Gruntfile</code>에서 <code>grunt.initConfig</code> 메서드를 통해서 지정한다. 일반적으로 환경설정은 task 명과 동일한 프로퍼티의 값으로 설정한다. 여러분이 설정한 task의 이름들과 충돌하지만 않으면 얼마든지 임의의 데이터를 넣을 수 있다. 물론 무시되지만.</p>
<p>또한, 이 파일은 JSON이 아닌 자바스크립트 파일이기 때문에, 모든 자바스크립트 코드를 사용할 수 있다. 필요하다면 동적으로 환경설정을 생성할 수도 있다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        <span class="comment">// concat task를 위한 환경설정은 여기에 넣는다.</span>
      },
      uglify: {
        <span class="comment">// uglify task를 위한 환경설정은 여기에 넣는다.</span>
      },
      <span class="comment">// 특정 task와 관련 없는 임의의 프로퍼티</span>
      my_property: <span class="string">'whatever'</span>,
      my_src_files: [<span class="string">'foo/*.js'</span>, <span class="string">'bar/*.js'</span>],
    });</code></pre>
<h2><a class="anchor" href="#task-configuration-and-targets" name="task-configuration-and-targets">Task Configuration and Targets</a></h2>
<p>task 하나가 실행되면, Grunt는 그 task의 이름으로 <code>Gruntfile</code>의 환경설정 객체에서 프로퍼티를 찾고 이를 해당 task의 환경설정으로 사용한다. 여러 일을 한 번에 하는 multi-task는 다시 별도의 target 명을 사용해서 환경설정을 개별적으로 가질 수 있다. 다음 예제를 보면 <code>uglify</code> task는 <code>bar</code> target만 가지고 있지만, <code>concat</code> task는 <code>foo</code>와 <code>bar</code>라는 두 개의 target을 갖고 있다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        foo: {
          <span class="comment">// concat task의 "foo" 타겟을 위한 옵션과 파일을 여기에 넣는다.</span>
        },
        bar: {
          <span class="comment">// concat task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다.</span>
        },
      },
      uglify: {
        bar: {
          <span class="comment">// uglify task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다.</span>
        },
      },
    });</code></pre>
<p><code>grunt concat</code>를 입력하면 모든 target을 순회하며, 차례대로 모든 target의 환경설정을 가져오는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target을 모두 사용해서 지정하면 특정 target의 환경설정만 가져온다. 단, task 명이 <a href="https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask">grunt.renameTask</a>로 변경되면, Grunt는 새로운 task 명으로 config 객체에서 프로퍼티 명을 찾는다.</p>
<h2><a class="anchor" href="#options" name="options">Options</a></h2>
<p>task 환경설정 하나를 살펴보자, <code>options</code> 프로퍼티는 내장된 기본값을 재정의 하기 위해서 덮어 쓸 때 사용한다. 그리고 각 target 별로도 해당 target에만 한정된 <code>options</code> 프로퍼티를 가질 수 있다. target 레벨의 options는 해당 타겟 레벨에서만 덮어써진다.</p>
<p><code>options</code> 프로퍼티는 필수요소가 아니며, 필요없는 경우 무시된다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        options: {
          <span class="comment">// task 수준의 옵션 객체. task 기본값을 덥어쓴다.</span>
        },
        foo: {
          options: {
            <span class="comment">// "foo" target 수준의 옵션 객체. task 수준의 options을 덥어쓴다.</span>
          },
        },
        bar: {
          <span class="comment">// 명시된 options가 없다. 이 target은 task 수준의 options을 사용한다.</span>
        },
      },
    });</code></pre>
<h2><a class="anchor" href="#files" name="files">Files</a></h2>
<p>대부분의 task는 파일을 대상으로하는 작업들이므로, Grunt는 task가 작업 대상 파일을 선언하기 위한 추상화된 기능을 강력하게 지원한다. <strong>src-dest</strong>(출처와 목적지)간의 파일 매핑을 정의하는 방법은 여러 가지가 있다. 매핑의 표현과 제어도 지속적으로 변경 가능하면서 말이다.
이제부터 설명할 유형들은 모든 task에서 사용할 수 있으므로, 여러분 상황에 맞는 포맷을 선택하면 된다.</p>
<p><code>src</code>와 <code>dest</code>는 모두 파일 포맷에서 지원하지만 &quot;Compact&quot;와 &quot;Files Array&quot; 포맷에서는 몇 가지 추가 프로퍼티를 사용할 수 있다.</p>
<ul>
<li><code>fileter</code>: 필터용도로 유효한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>이나 함수를 적용한다. 이때, 함수는 적절한 <code>src</code> 파일경로를 받으면 <code>true</code>나 <code>false</code>를 반환해야 한다.</li>
<li><code>nonull</code>: <code>true</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 그 패턴 자체를 담은 목록을 반환하고, <code>false</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 빈 목록을 반환한다. <code>--verbos</code>와 함께 사용하면 파일 경로 관련 버그를 찾을 때 유용하다.</li>
<li><code>dot</code>: <code>true</code>면 패턴에 명시적으로 포함시키지 않아도 구두점(.)으로 시작하는 파일명을 일치시킨다.(src/*.js 하면 hidden files도 포함된다는 말.)</li>
<li><code>matchBase</code>: <code>true</code>면, 슬래시(/)를 포함하지 않은 패턴들이 슬래시를 가지고 있을 경로 기본명을 제외하고 매치된다. 예를 들어 <code>a?b</code> 패턴이 <code>/xyz/acb/123</code>이 아니라 <code>/xyz/123/acb</code>와 일치한다.</li>
<li><code>expand</code>은 동적인 src-dest 파일 매핑을 수행한다. 더 자세한 정보는 <a href="/configuring-tasks#building-the-files-object-dynamically">Building the files object dynamically</a>를 참고한다.</li>
<li>이 이외의 프로퍼티들은 매칭 옵션으로 하위 libs로 전달된다. 추가 옵션은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>를 보자.</li>
</ul>
<h3><a class="anchor" href="#compact-format" name="compact-format">Compact Format</a></h3>
<p>이 형태는 target 별로 단일 <strong>src-dest</strong> 파일 매핑을 할 때 사용한다. 주로 <a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>처럼 <code>dest</code>와 관계없이 <code>src</code> 프로퍼티 하나만 필요한 읽기 전용 task를 위해서 사용한다. src-dest 파일 매핑 별로 프로퍼티 확장도 가능하다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      jshint: {
        foo: {
          src: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>]
        },
      },
      concat: {
        bar: {
          src: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],
          dest: <span class="string">'dest/b.js'</span>,
        },
      },
    });</code></pre>
<h3><a class="anchor" href="#files-object-format" name="files-object-format">Files Object Format</a></h3>
<p>이 형태는 target 별로 다중 src-dest 매핑을 할 때 사용한다. 프로퍼티 명이 목적지(destination) 파일명이고 프로퍼티 값은 출처(source) 파일이 된다. 이 방법을 사용하면 src-dest 파일 매핑이 아무리 많아도 지정할 수 있다. 하지만 매핑 별로 추가 파라미터 지정은 불가능하다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        foo: {
          files: {
            <span class="string">'dest/a.js'</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>],
            <span class="string">'dest/a1.js'</span>: [<span class="string">'src/aa1.js'</span>, <span class="string">'src/aaa1.js'</span>],
          },
        },
        bar: {
          files: {
            <span class="string">'dest/b.js'</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],
            <span class="string">'dest/b1.js'</span>: [<span class="string">'src/bb1.js'</span>, <span class="string">'src/bbb1.js'</span>],
          },
        },
      },
    });</code></pre>
<h3><a class="anchor" href="#files-array-format" name="files-array-format">Files Array Format</a></h3>
<p>이 형태는 target 별로 다중 src-dest 매핑을 지원하면서 매핑 별로 추가 프로퍼티를 사용할 수 있다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        foo: {
          files: [
            {src: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>], dest: <span class="string">'dest/a.js'</span>},
            {src: [<span class="string">'src/aa1.js'</span>, <span class="string">'src/aaa1.js'</span>], dest: <span class="string">'dest/a1.js'</span>},
          ],
        },
        bar: {
          files: [
            {src: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>], dest: <span class="string">'dest/b/'</span>, nonull: <span class="literal">true</span>},
            {src: [<span class="string">'src/bb1.js'</span>, <span class="string">'src/bbb1.js'</span>], dest: <span class="string">'dest/b1/'</span>, filter: <span class="string">'isFile'</span>},
          ],
        },
      },
    });</code></pre>
<h3><a class="anchor" href="#older-formats" name="older-formats">Older Formats</a></h3>
<p><strong>dest as targets</strong> 파일 형태는 멀티 task와 target가 있기 전부터 있던 형태로 목적지(destination) 파일 경로가 그대로 target 명이 된다. 하지만 이 때문에 <code>grunt task:target</code>의 형태로 동작시키기가 거북할 수 있다. 또한 src-dest 매핑 별로 target 수준의 옵션이나 추가 프로퍼티를 지정할 수 없다.</p>
<p>이 형태는 되도록 사용하지 말고 가능하면 피하자.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        <span class="string">'dest/a.js'</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>],
        <span class="string">'dest/b.js'</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],
      },
    });</code></pre>
<h3><a class="anchor" href="#custom-filter-function" name="custom-filter-function">Custom Filter Function</a></h3>
<p><code>filter</code> 프로퍼티를 사용하면 파일을 좀 더 꼼꼼하게 지정할 수 있다. 그냥 적절한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>을 사용하자. 다음 예제는 패턴과 일치하는 파일만 제거(clean)한다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      clean: {
        foo: {
          src: [<span class="string">'tmp/**/*'</span>],
          filter: <span class="string">'isFile'</span>,
        },
      },
    });</code></pre>
<p>아니면 파일 일치 여부에 따라 <code>true</code>, <code>false</code>를 반환하는 <code>filter</code>용 함수를 생성하자. 다음 예제는 빈 폴더만 지우는 필터다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      clean: {
        foo: {
          src: [<span class="string">'tmp/**/*'</span>],
          filter: <span class="keyword">function</span>(filepath) {
            <span class="keyword">return</span> (grunt.file.isDir(filepath) &amp;&amp; require(<span class="string">'fs'</span>).readdirSync(filepath).length === <span class="number">0</span>);
          },
        },
      },
    });</code></pre>
<h3><a class="anchor" href="#globbing-patterns" name="globbing-patterns">Globbing patterns</a></h3>
<p>대상(source) 파일 경로를 모두 개별적으로 지정하는 일이 불가능할 때도 있다. 그래서 Grunt는 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>라이브러리를 내부에 포함시켰고, 이를 통해서 파일명 확장을 지원한다. (globbing이라고도 한다.)</p>
<p>이 문서는 globbing 패턴 전반을 다루는 튜토리얼이 아니므로, 파일경로에서 사용할 수 있는 몇 가지만 소개한다.</p>
<ul>
<li><code>*</code>는 개수와 관계없이 <code>/</code>를 제외한 모든 캐릭터와 일치한다.</li>
<li><code>?</code>는 <code>/</code>를 제외한 하나의 캐릭터와 일치한다.</li>
<li><code>**</code>는 개수와 관계없이 <code>/</code>를 포함한 모든 캐릭터와 일치한다. 하지만 경로부분(폴더명)에서만 동작한다.</li>
<li><code>{}</code>에 콤마로 구분된 목록을 넣으면 &quot;or&quot; 표현식으로 동작한다.</li>
<li><code>!</code>를 패턴의 처음에 사용하면 불일치(negative match)를 의미한다.</li>
</ul>
<p>globbing 패턴을 잘 모르더라도 <code>foo/*.js</code>는 <code>foo/</code> 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치하지만, <code>foo/**/*.js</code>는 <code>foo/</code> 폴더와 그 아래의 모든 하위 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치한다는 것 정도는 알아두면 좋다.</p>
<p>globbing 패턴의 복잡함을 줄이기 위해서, Grunt에서는 파일 경로나 globbing 패턴을 배열로 지정할 수 있다. 패턴은 모두 배열의 색인 순서대로 처리되는데, 결과 집합에서 일치하는 파일을 제외하는 <code>!</code> 접두사 패턴도 마찬가지다. 최종 결과 집합은 중복값이 없는 유일값들이다.</p>
<p>예제을 보자.</p>
<pre><code class="lang-js">    <span class="comment">// 단일 파일 지정.</span>
    {src: <span class="string">'foo/this.js'</span>, dest: ...}
    <span class="comment">// 배열로 여러 파일 지정.</span>
    {src: [<span class="string">'foo/this.js'</span>, <span class="string">'foo/that.js'</span>, <span class="string">'foo/the-other.js'</span>], dest: ...}
    <span class="comment">// glob 패턴 사용.</span>
    {src: <span class="string">'foo/th*.js'</span>, dest: ...}

    <span class="comment">// 단일 node-glob 패턴.</span>
    {src: <span class="string">'foo/{a,b}*.js'</span>, dest: ...}
    <span class="comment">// 물론 이렇게도 사용 가능.</span>
    {src: [<span class="string">'foo/a*.js'</span>, <span class="string">'foo/b*.js'</span>], dest: ...}

    <span class="comment">// foo/ 안의 모든 .js 파일. 순서는 알파벳 순.</span>
    {src: [<span class="string">'foo/*.js'</span>], dest: ...}
    <span class="comment">// bar.js을 먼저 선택하고, 남은 파일을 알파벳 순으로 추가.</span>
    {src: [<span class="string">'foo/bar.js'</span>, <span class="string">'foo/*.js'</span>], dest: ...}

    <span class="comment">// bar.js를 제외한 모든 파일. 알파벳 순.</span>
    {src: [<span class="string">'foo/*.js'</span>, <span class="string">'!foo/bar.js'</span>], dest: ...}
    <span class="comment">// 모든 파일을 알파벳 순서로 넣고, 끝에 bar.js를 추가.</span>
    {src: [<span class="string">'foo/*.js'</span>, <span class="string">'!foo/bar.js'</span>, <span class="string">'foo/bar.js'</span>], dest: ...}

    <span class="comment">// 파일경로나 glob 패턴에 템플릿(&lt;%%&gt;)을 사용할 수도 있다.</span>
    {src: [<span class="string">'src/&lt;%= basename %&gt;.js'</span>], dest: <span class="string">'build/&lt;%= basename %&gt;.min.js'</span>}
    <span class="comment">// 환경설정의 다른 task의 target에서 정의한 파일 목록을 참조할 수도 있다.</span>
    {src: [<span class="string">'foo/*.js'</span>, <span class="string">'&lt;%= jshint.all.src %&gt;'</span>], dest: ...}</code></pre>
<p>더 자세한 glob 패턴 문법은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a> 문서를 참고하자.</p>
<h3><a class="anchor" href="#building-the-fiels-object-dynamically" name="building-the-fiels-object-dynamically">Building the fiels object dynamically</a></h3>
<p>대량의 파일들을 처리하고자 할 때, 파일 목록을 동적으로 생성하는데 사용가능한 몇 가지 추가 프로퍼티들이 있다. 이 프로퍼티들은 &quot;Compact&quot;와 &quot;Files Array&quot; 매핑 패턴에 지정할 수 있다.</p>
<ul>
<li><code>expand</code>: 다음 옵션들을 활성화하려면 먼저 이 프로퍼티를 <code>true</code>로 설정한다.</li>
<li><code>cwd</code>: 모든 <code>src</code> 패턴을 이 옵션에 정의된 경로를 기준으로 정한다.</li>
<li><code>src</code>: 일치 여부 확인을 위한 패턴 목록. <code>cwd</code>기준 상대경로.</li>
<li><code>dest</code>: 목적지 지정을 위한 경로 접두사.</li>
<li><code>ext</code>: <code>dest</code> 경로에 생성할 파일의 확장자.</li>
<li><code>flatten</code>: <code>dest</code> 경로에 생성할 목록에서 경로부분을 제거하고 파일명만 남긴다.</li>
<li><code>rename</code>: 일치하는 <code>src</code> 파일별로 호출되는 함수. 이 함수는 (확장자 변경과 경로 제거 후) 일치하는 <code>src</code> 패턴과 <code>dest</code>를 인자로 받아서, 새로운 <code>dest</code> 값을 반환해야 한다. 동일 <code>dest</code> 값이 여러 번 반환되면, 사용된 <code>src</code>들이 이름변경을 위한 출처 배열에 추가된다.</li>
</ul>
<p>다음 <code>minify</code> task 예제는 <code>static_mappings</code>와 <code>dynamic_mappings</code> target에서 동일한 src-dest 파일 매핑을 바라보고 있다. task를 실행하면, Grunt는 자동으로 <code>dynamic_mappings</code> 파일 목록을 정적인 4개의 src-dest 파일 매핑으로 바꾼다.</p>
<p>또한, 정적인 매핑과 동적인 매핑은 다양한 방법으로 함께 쓸 수 있다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      minify: {
        static_mappings: {
          <span class="comment">// 이 src-dest 파일 매핑은 수동으로 지정했기 때문에,</span>
          <span class="comment">// 파일 추가 삭제와 Grunfile 수정을 매번 해줘야 한다.</span>
          files: [
            {src: <span class="string">'lib/a.js'</span>, dest: <span class="string">'build/a.min.js'</span>},
            {src: <span class="string">'lib/b.js'</span>, dest: <span class="string">'build/b.min.js'</span>},
            {src: <span class="string">'lib/subdir/c.js'</span>, dest: <span class="string">'build/subdir/c.min.js'</span>},
            {src: <span class="string">'lib/subdir/d.js'</span>, dest: <span class="string">'build/subdir/d.min.js'</span>},
          ],
        },
        dynamic_mappings: {
          <span class="comment">// "minify" task가 실행되면 Grunt는 "lib/" 아래에서 "**/*.js"를 찾는다.</span>
          <span class="comment">// 그렇게 찾은 src-dest 파일 매핑으로 빌드한다.</span>
          <span class="comment">// 파일이 추가/제거 될 때 마다 Gruntfile을 수정할 필요없다.</span>
          files: [
            {
              expand: <span class="literal">true</span>,     <span class="comment">// 동적 기술법을 활성화.</span>
              cwd: <span class="string">'lib/'</span>,      <span class="comment">// Src 패턴의 기준 폴더.</span>
              src: [<span class="string">'**/*.js'</span>], <span class="comment">// 비교에 사용할 패턴 목록.</span>
              dest: <span class="string">'build/'</span>,   <span class="comment">// 목적 경로의 접두사(사실상 폴더명)</span>
              ext: <span class="string">'.min.js'</span>,   <span class="comment">// dest의 파일들의 확장자.</span>
            },
          ],
        },
      },
    });</code></pre>
<h2><a class="anchor" href="#templates" name="templates">Templates</a></h2>
<p><code>&lt;%%&gt;</code> 구분자를 사용한 템플릿은 task가 해당 환경설정을 읽어올 때 자동으로 정적인 값으로 기술된다. 그리고 이는 템플릿를 모두 기술될 때 까지 재귀적으로 실행된다.</p>
<p><code>grunt.initConfig()</code>의 환경설정 객체는 프로퍼티 설정시 컨텍스트로 사용되며, <code>grunt</code>와 그 메서드도 그 안에서 사용할 수 있다. 예) <code>&lt;%= grunt.template.today(&#39;yyyy-mm-dd&#39;) %&gt;</code></p>
<ul>
<li><code>&lt;%= prop.subprop%&gt;</code>는 환경설정 객체에서 <code>prop.subprop</code>을 찾아서 그 값으로 치환된다. 타입은 관계없다. 이같은 템플릿은 문자열 만이 아니라 배열과 다른 객체로 참조할 수도 있다.</li>
<li><code>&lt;% %&gt;</code>는 임의의 인라인 자바스크립트 코드를 실행한다. 그래서 흐름제어나 순회를 위해 사용할 수 있다.</li>
</ul>
<p>여기 <code>concat</code> task가 있다. <code>grunt concat:sample</code>을 실행하면 <code>foo/*.js</code> + <code>bar/*.js</code> + <code>baz/*.js</code>와 일치하는 파일을 합치고 <code>/* abcde */</code> 상단 주석(banner)를 추가해서 <code>build/abcde.js</code>란 이름으로 생성한다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      concat: {
        sample: {
          options: {
            banner: <span class="string">'/* &lt;%= baz %&gt; */\n'</span>,   <span class="comment">// '/* abcde */\n'</span>
          },
          src: [<span class="string">'&lt;%= qux %&gt;'</span>, <span class="string">'baz/*.js'</span>],  <span class="comment">// [['foo/*.js', 'bar/*.js'], 'baz/*.js']</span>
          dest: <span class="string">'build/&lt;%= baz %&gt;.js'</span>,      <span class="comment">// 'build/abcde.js'</span>
        },
      },
      <span class="comment">// task 환경설정 템플릿에 사용되는 임의의 프로퍼티들</span>
      foo: <span class="string">'c'</span>,
      bar: <span class="string">'b&lt;%= foo %&gt;d'</span>, <span class="comment">// 'bcd'</span>
      baz: <span class="string">'a&lt;%= bar %&gt;e'</span>, <span class="comment">// 'abcde'</span>
      qux: [<span class="string">'foo/*.js'</span>, <span class="string">'bar/*.js'</span>],
    });</code></pre>
<h2><a class="anchor" href="#importing-external-data" name="importing-external-data">Importing External Data</a></h2>
<p>다음 <code>Gruntfile</code> 파일은 <code>package.json</code> 파일에서 프로젝트 관련 메타데이터를 가져온다. 그리고 그 메타데이터를 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify 플러그인</a>의 <code>uglify</code> task의 상단 주석 생성과 src 파일 minify를 위한 정보로 사용한다.</p>
<p>Grunt는 JSON과 YAML 데이터를 가져올 수 있는 <code>grunt.file.readJSON</code>와 <code>grunt.file.readYAML</code>를 지원한다.</p>
<pre><code class="lang-js">    grunt.initConfig({
      pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),
      uglify: {
        options: {
          banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'</span>
        },
        dist: {
          src: <span class="string">'src/&lt;%= pkg.name %&gt;.js'</span>,
          dest: <span class="string">'dist/&lt;%= pkg.name %&gt;.min.js'</span>
        }
      }
    });</code></pre>
<div class="end-link">Found an error in the documentation?
<a href='https://github.com/gruntjs/grunt-docs/issues'>File an issue</a>.</div></div></div><div class="span3"><div class="well sidebar-nav"><ul class="nav nav-list"><li class="nav-header"><i class="icon-document-alt-stroke"></i><span>Documentation</span></li><li><a href="/getting-started" class="false">Getting Started</a></li><li><a href="/configuring-tasks" class="active">Configuring Tasks</a></li><li><a href="/sample-gruntfile" class="false">Sample Gruntfile</a></li><li><a href="/creating-tasks" class="false">Creating Tasks</a></li><li><a href="/creating-plugins" class="false">Creating Plugins</a></li><li><a href="/using-the-cli" class="false">Using the CLI</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>Advanced</span></li><li><a href="/installing-grunt" class="false">Installing Grunt</a></li><li><a href="/frequently-asked-questions" class="false">Frequently Asked Questions</a></li><li><a href="/project-scaffolding" class="false">Project Scaffolding</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>Community</span></li><li><a href="/help-resources" class="false">Help Resources</a></li><li><a href="/who-uses-grunt" class="false">Who uses Grunt</a></li><li><a href="/contributing" class="false">Contributing</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>Migration guides</span></li><li><a href="/upgrading-from-0.3-to-0.4" class="false">Upgrading from 0.3 to 0.4</a></li></ul><div class="advertisements"><script>var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script><script>var ados = ados || {};ados.run = ados.run || [];ados.run.push(function() {/* load placement for account: Bocoup, site: Grunt, size: 120x90 - Button 1 and Text*/ados_add_placement(4433, 27854, "azk48893", 1);ados_load();});</script><div id="azk48893"></div><span class="adsbybocoup">Ads by <a href="http://bocoup.com">Bocoup</a>.</span></div></div></div></div></div></div><footer class="grunt-footer"><div class="inner"><div class="container"><ul class="pull-right"><li><a href="/blog">Blog</a></li><li><a href="/upgrading-from-0.3-to-0.4">Migration Guides</a></li><li><a href="/contributing">Contributing</a></li><li class="social"><a href="https://github.com/gruntjs/" alt="Grunt on GitHub"><span class="icon-github"></span></a></li><li class="social"><a href="https://twitter.com/gruntjs/" alt="Grunt on Twitter"><span class="icon-twitter"></span></a></li><li class="social"><a href="/rss" alt="Grunt blog RSS feed"><span class="icon-feed"></span></a></li></ul><ul class="pull-left"><li>Grunt development is sponsored by<a href="http://bocoup.com/" alt="Bocoup">Bocoup</a></li></ul></div></div></footer><script>var _gaq=[['_setAccount','UA-44802186-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script><script>document.write('<script type="text/javascript" src="' + ('https:'==document.location.protocol?'https://':'http://c.') + 'jslogger.com/jslogger.js"><\/script>');</script><script>window.jslogger = new JSLogger();</script></body></html>